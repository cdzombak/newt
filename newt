#!/usr/bin/env bash
set -euo pipefail

VERSION="<dev>"

usage() {
  cat <<'EOF'
Usage: newt [-b] <branch>
       newt -d <worktree>
       newt -l

Create a git worktree rooted in <repo>/.newt/<branch>, with slashes in the
branch name replaced by hyphens. Use -b to create the worktree on a new branch.
Use -d to delete a worktree and its branch (asks for confirmation if not merged).
Use -l to list worktrees with their merge status.
EOF
  exit 1
}

create_branch=false
do_delete=false
do_list=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -b)
      create_branch=true
      shift
      ;;
    -d)
      do_delete=true
      shift
      ;;
    -l)
      do_list=true
      shift
      ;;
    -v|--version)
      echo "newt ${VERSION}"
      exit 0
      ;;
    -h|--help)
      usage
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Error: unknown option $1" >&2
      usage
      ;;
    *)
      break
      ;;
  esac
done

if ( $do_delete && $create_branch ) || \
   ( $do_list && $create_branch ) || \
   ( $do_list && $do_delete ); then
  echo "Error: -b, -d, and -l cannot be combined." >&2
  usage
fi

if ! repo_root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  echo "Error: not inside a git repository." >&2
  exit 1
fi

# Ensure .newt is excluded from the repo.
exclude_file="${repo_root}/.git/info/exclude"
ensure_newt_excluded() {
  if [[ -f "$exclude_file" ]] && grep -Fxq ".newt" "$exclude_file"; then
    return
  fi

  if (cd "$repo_root" && git exclude .newt >/dev/null 2>&1); then
    return
  fi

  mkdir -p "$(dirname "$exclude_file")"
  {
    echo ""
    echo ".newt"
  } >> "$exclude_file"
}

ensure_newt_excluded

delete_worktree() {
  local worktree_name="$1"
  local worktree_base="${repo_root}/.newt"
  local worktree_path="${worktree_base}/${worktree_name}"

  if [[ ! -d "$worktree_path" ]]; then
    echo "Error: worktree '${worktree_name}' not found." >&2
    exit 1
  fi

  # Get the branch for this worktree
  declare -A branch_for_path=()
  local current_path=""
  local line=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_path="${line#worktree }"
        ;;
      branch\ *)
        branch_for_path["$current_path"]="${line#branch }"
        ;;
    esac
  done < <(git -C "$repo_root" worktree list --porcelain)

  local branch="${branch_for_path["$worktree_path"]-}"
  if [[ -z "$branch" ]]; then
    echo "Error: could not determine branch for worktree '${worktree_name}'." >&2
    exit 1
  fi

  # Handle refs/heads/ prefix if present
  branch="${branch#refs/heads/}"

  # Auto-detect default branch
  local default_branch=""
  if default_branch=$(git -C "$repo_root" symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null); then
    default_branch="${default_branch#origin/}"
  else
    # Fallback to checking common branch names
    for branch_candidate in main master develop; do
      if git -C "$repo_root" rev-parse --verify --quiet "$branch_candidate" >/dev/null 2>&1; then
        default_branch="$branch_candidate"
        break
      fi
    done
  fi

  if [[ -z "$default_branch" ]]; then
    echo "Error: could not detect default branch (tried main, master, develop)." >&2
    exit 1
  fi

  # Check if branch is merged
  local is_merged=false
  if git -C "$repo_root" merge-base --is-ancestor "$branch" "$default_branch" 2>/dev/null; then
    is_merged=true
  fi

  # Ask for confirmation if not merged
  if ! $is_merged; then
    echo "Warning: branch '${branch}' has not been merged into '${default_branch}'." >&2
    read -r -p "Are you sure you want to delete this worktree and branch? [y/N] " response
    case "$response" in
      [yY][eE][sS]|[yY])
        # Continue with deletion
        ;;
      *)
        echo "Deletion cancelled."
        exit 0
        ;;
    esac
  fi

  # Remove the worktree
  if ! git -C "$repo_root" worktree remove "$worktree_path"; then
    echo "Error: failed to remove worktree at ${worktree_path}." >&2
    exit 1
  fi
  echo "Removed worktree at ${worktree_path}"

  # Delete the branch
  if ! git -C "$repo_root" branch -D "$branch" >/dev/null 2>&1; then
    echo "Warning: failed to delete branch '${branch}'." >&2
    exit 1
  fi
  echo "Deleted branch '${branch}'"
}

list_worktrees() {
  local worktree_base="${repo_root}/.newt"

  if [[ ! -d "$worktree_base" ]]; then
    echo "No worktrees found."
    return
  fi

  # Auto-detect default branch
  local default_branch=""
  if default_branch=$(git -C "$repo_root" symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null); then
    default_branch="${default_branch#origin/}"
  else
    # Fallback to checking common branch names
    for branch in main master develop; do
      if git -C "$repo_root" rev-parse --verify --quiet "$branch" >/dev/null 2>&1; then
        default_branch="$branch"
        break
      fi
    done
  fi

  if [[ -z "$default_branch" ]]; then
    echo "Error: could not detect default branch (tried main, master, develop)." >&2
    return 1
  fi

  # Parse worktree list
  declare -A branch_for_path=()
  local current_path=""
  local line=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_path="${line#worktree }"
        ;;
      branch\ *)
        branch_for_path["$current_path"]="${line#branch }"
        ;;
    esac
  done < <(git -C "$repo_root" worktree list --porcelain)

  # List worktrees in .newt directory
  shopt -s nullglob
  local found=0
  local path=""
  for path in "${worktree_base}"/*; do
    [[ -d "$path" ]] || continue
    local branch="${branch_for_path["$path"]-}"

    # Skip if no branch info or detached HEAD
    if [[ -z "$branch" ]]; then
      continue
    fi

    # Handle refs/heads/ prefix if present
    branch="${branch#refs/heads/}"

    # Get worktree name (basename)
    local worktree_name
    worktree_name="$(basename "$path")"

    # Check merge status
    local status=""
    local status_color=""
    if git -C "$repo_root" merge-base --is-ancestor "$branch" "$default_branch" 2>/dev/null; then
      status="merged"
      status_color="\033[32m"  # Green
    else
      status="unmerged"
      status_color="\033[31m"  # Red
    fi

    # Output with formatting
    # Bold worktree name, plain branch name in parens, colored status in brackets
    printf "\033[1m%s\033[0m (%s) [%b%s\033[0m]\n" \
      "$worktree_name" "$branch" "$status_color" "$status"

    found=$((found + 1))
  done
  shopt -u nullglob

  if [[ $found -eq 0 ]]; then
    echo "No worktrees found in ${worktree_base}."
  fi
}

if $do_delete; then
  if [[ $# -ne 1 ]]; then
    echo "Error: -d requires exactly one argument (worktree name)." >&2
    usage
  fi
  delete_worktree "$1"
  exit 0
fi

if $do_list; then
  if [[ $# -ne 0 ]]; then
    usage
  fi
  list_worktrees
  exit 0
fi

if [[ $# -ne 1 ]]; then
  usage
fi

branch_name="$1"
sane_branch="${branch_name//\//-}"
worktree_dir="${repo_root}/.newt/${sane_branch}"

mkdir -p "${repo_root}/.newt"

if [[ -e "$worktree_dir" ]]; then
  echo "Error: worktree directory ${worktree_dir} already exists." >&2
  exit 1
fi

git_cmd=(git -C "$repo_root" worktree add)
if $create_branch; then
  git_cmd+=(-b "$branch_name")
  git_cmd+=("$worktree_dir")
else
  git_cmd+=("$worktree_dir" "$branch_name")
fi

"${git_cmd[@]}"

cd "$worktree_dir"

exec "${SHELL:-/bin/sh}"
