#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: newt [-b] <branch>
       newt -c
       newt -l

Create a git worktree rooted in <repo>/.newt/<branch>, with slashes in the
branch name replaced by hyphens. Use -b to create the worktree on a new branch.
Use -c to remove worktrees whose branches no longer exist.
Use -l to list worktrees with their merge status.
EOF
  exit 1
}

create_branch=false
do_cleanup=false
do_list=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -b)
      create_branch=true
      shift
      ;;
    -c)
      do_cleanup=true
      shift
      ;;
    -l)
      do_list=true
      shift
      ;;
    -h|--help)
      usage
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Error: unknown option $1" >&2
      usage
      ;;
    *)
      break
      ;;
  esac
done

if ( $do_cleanup && $create_branch ) || \
   ( $do_list && $create_branch ) || \
   ( $do_list && $do_cleanup ); then
  echo "Error: -b, -c, and -l cannot be combined." >&2
  usage
fi

if ! repo_root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
  echo "Error: not inside a git repository." >&2
  exit 1
fi

# Ensure .newt is excluded from the repo.
exclude_file="${repo_root}/.git/info/exclude"
ensure_newt_excluded() {
  if [[ -f "$exclude_file" ]] && grep -Fxq ".newt" "$exclude_file"; then
    return
  fi

  if (cd "$repo_root" && git exclude .newt >/dev/null 2>&1); then
    return
  fi

  mkdir -p "$(dirname "$exclude_file")"
  {
    echo ""
    echo ".newt"
  } >> "$exclude_file"
}

ensure_newt_excluded

cleanup_stale_worktrees() {
  local worktree_base="${repo_root}/.newt"

  if [[ ! -d "$worktree_base" ]]; then
    echo "No worktrees to clean."
    return
  fi

  declare -A branch_for_path=()
  local current_path=""
  local line=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_path="${line#worktree }"
        ;;
      branch\ *)
        branch_for_path["$current_path"]="${line#branch }"
        ;;
    esac
  done < <(git -C "$repo_root" worktree list --porcelain)

  shopt -s nullglob
  local cleaned=0
  local path=""
  for path in "${worktree_base}"/*; do
    [[ -d "$path" ]] || continue
    local branch="${branch_for_path["$path"]-}"
    if [[ -z "$branch" ]] || [[ "$branch" == "("* ]]; then
      continue
    fi

    if git -C "$repo_root" rev-parse --verify --quiet "${branch}^{commit}" >/dev/null 2>&1; then
      continue
    fi

    if git -C "$repo_root" worktree remove --force "$path" >/dev/null 2>&1; then
      echo "Removed stale worktree at $path (branch: $branch)"
      cleaned=$((cleaned + 1))
    else
      echo "Warning: failed to remove worktree at $path" >&2
    fi
  done
  shopt -u nullglob

  if [[ $cleaned -eq 0 ]]; then
    echo "No stale worktrees found."
  else
    echo "Removed $cleaned stale worktree(s)."
  fi
}

list_worktrees() {
  local worktree_base="${repo_root}/.newt"

  if [[ ! -d "$worktree_base" ]]; then
    echo "No worktrees found."
    return
  fi

  # Auto-detect default branch
  local default_branch=""
  if default_branch=$(git -C "$repo_root" symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null); then
    default_branch="${default_branch#origin/}"
  else
    # Fallback to checking common branch names
    for branch in main master develop; do
      if git -C "$repo_root" rev-parse --verify --quiet "$branch" >/dev/null 2>&1; then
        default_branch="$branch"
        break
      fi
    done
  fi

  if [[ -z "$default_branch" ]]; then
    echo "Error: could not detect default branch (tried main, master, develop)." >&2
    return 1
  fi

  # Parse worktree list
  declare -A branch_for_path=()
  local current_path=""
  local line=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_path="${line#worktree }"
        ;;
      branch\ *)
        branch_for_path["$current_path"]="${line#branch }"
        ;;
    esac
  done < <(git -C "$repo_root" worktree list --porcelain)

  # List worktrees in .newt directory
  shopt -s nullglob
  local found=0
  local path=""
  for path in "${worktree_base}"/*; do
    [[ -d "$path" ]] || continue
    local branch="${branch_for_path["$path"]-}"

    # Skip if no branch info or detached HEAD
    if [[ -z "$branch" ]]; then
      continue
    fi

    # Handle refs/heads/ prefix if present
    branch="${branch#refs/heads/}"

    # Get worktree name (basename)
    local worktree_name
    worktree_name="$(basename "$path")"

    # Check merge status
    local status=""
    local status_color=""
    if git -C "$repo_root" merge-base --is-ancestor "$branch" "$default_branch" 2>/dev/null; then
      status="merged"
      status_color="\033[32m"  # Green
    else
      status="unmerged"
      status_color="\033[31m"  # Red
    fi

    # Output with formatting
    # Bold worktree name, plain branch name in parens, colored status in brackets
    printf "\033[1m%s\033[0m (%s) [%b%s\033[0m]\n" \
      "$worktree_name" "$branch" "$status_color" "$status"

    found=$((found + 1))
  done
  shopt -u nullglob

  if [[ $found -eq 0 ]]; then
    echo "No worktrees found in ${worktree_base}."
  fi
}

if $do_cleanup; then
  if [[ $# -ne 0 ]]; then
    usage
  fi
  cleanup_stale_worktrees
  exit 0
fi

if $do_list; then
  if [[ $# -ne 0 ]]; then
    usage
  fi
  list_worktrees
  exit 0
fi

if [[ $# -ne 1 ]]; then
  usage
fi

branch_name="$1"
sane_branch="${branch_name//\//-}"
worktree_dir="${repo_root}/.newt/${sane_branch}"

mkdir -p "${repo_root}/.newt"

if [[ -e "$worktree_dir" ]]; then
  echo "Error: worktree directory ${worktree_dir} already exists." >&2
  exit 1
fi

git_cmd=(git -C "$repo_root" worktree add)
if $create_branch; then
  git_cmd+=(-b "$branch_name")
  git_cmd+=("$worktree_dir")
else
  git_cmd+=("$worktree_dir" "$branch_name")
fi

"${git_cmd[@]}"

cd "$worktree_dir"

exec "${SHELL:-/bin/sh}"
